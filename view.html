<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ChatGraph - A 3D Conversation Explorer</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script>

  <style>
    body { 
      font-family: 'Roboto', sans-serif;
      background-color: #0d1117; /* Deep dark background */
      color: #c9d1d9; /* Light text color */
    }
    #plot-container { 
      width: 100%; 
      min-height: 70vh; 
      cursor: grab; 
      outline: none;
    }
    input[type="file"] { display: none; }

    .font-space { font-family: 'Space Grotesk', sans-serif; }

    .glass-pane {
      background: rgba(22, 27, 34, 0.7); /* Dark glass */
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1); /* Faint border */
    }

    .btn-primary {
      background: linear-gradient(45deg, #00FFFF 0%, #9D00FF 100%); /* Cyan to Purple */
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
    }
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 255, 255, 0.35);
    }

    #plot-container-wrapper {
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.1), 0 0 15px rgba(157, 0, 255, 0.1) inset;
    }

  </style>
</head>
<body class="antialiased">

  <!-- Container -->
  <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-6">

    <!-- Header -->
    <header class="flex justify-between items-center mb-8 animate-fade-in-down">
      <div>
        <h1 class="text-3xl font-bold text-gray-100 font-space tracking-tighter">
          ChatGraph
        </h1>
        <p class="text-gray-400 text-sm">
          To convert your chat with GPT into a visualization, head to my GitHub repo abh1hi/chatgraph and don't forget to follow abh1hi/chatgraph.
        </p>
      </div>
      <div class="flex items-center gap-4">
        <button id="legend-toggle-btn" class="bg-gray-800 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-lg shadow-sm transition-all border border-gray-700">
            Legend
        </button>
        <label for="json-upload" class="btn-primary text-black font-bold py-2 px-5 rounded-lg shadow-lg cursor-pointer">
          Upload Data
        </label>
      </div>
    </header>

    <!-- Main Content -->
    <main class="flex flex-col lg:flex-row gap-8">
        <!-- Graph Section -->
        <div id="plot-container-wrapper" class="flex-grow glass-pane rounded-2xl p-4 animate-fade-in-up">
            <div id="plot-container"></div>
        </div>
    </main>

    <!-- Upload Info -->
    <div class="text-center mt-6 text-sm text-gray-400">
      <p id="file-info">Ready for data. Upload a JSON file to begin.</p>
      <p id="message-area" class="h-5 mt-1"></p>
    </div>

    <input type="file" id="json-upload" accept=".json">

  </div>

  <!-- Details Sidebar -->
  <aside id="conversation-sidebar" class="fixed top-0 right-0 h-full w-full max-w-lg glass-pane p-8 transform translate-x-full transition-transform duration-500 ease-in-out z-50 flex flex-col">
    <div class="flex justify-between items-center mb-6 pb-4 border-b border-gray-700">
      <h3 class="text-2xl font-bold text-gray-100 font-space">Details</h3>
      <button id="close-sidebar-btn" class="text-gray-400 hover:text-white focus:outline-none rounded-full p-2 transition-colors">
        ✕
      </button>
    </div>
    <div id="sidebar-content" class="overflow-y-auto flex-grow text-gray-300 space-y-4 pr-4">
      <p>Select a node to explore the conversation.</p>
    </div>
  </aside>

  <!-- Legend Sidebar -->
  <aside id="legend-sidebar" class="fixed top-0 left-0 h-full w-full max-w-xs glass-pane p-8 transform -translate-x-full transition-transform duration-500 ease-in-out z-50 flex flex-col">
    <div class="flex justify-between items-center mb-6 pb-4 border-b border-gray-700">
      <h3 class="text-2xl font-bold text-gray-100 font-space">Legend</h3>
      <button id="close-legend-btn" class="text-gray-400 hover:text-white focus:outline-none rounded-full p-2 transition-colors">
        ✕
      </button>
    </div>
    <div id="legend-content" class="overflow-y-auto flex-grow text-gray-300 space-y-3 pr-4">
      <!-- Legend items will be populated here -->
    </div>
  </aside>
  
  <!-- Hover Tooltip -->
  <div id="tooltip" class="fixed hidden glass-pane rounded-md p-3 text-sm max-w-xs z-50 pointer-events-none"></div>


  <!-- Animations -->
  <style>
    @keyframes fade-in-down { from { opacity: 0; transform: translateY(-15px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes fade-in-up { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
    .animate-fade-in-down { animation: fade-in-down 0.7s ease-out both; }
    .animate-fade-in-up { animation: fade-in-up 0.7s 0.2s ease-out both; }
  </style>

  <!-- Your Logic -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const plotContainer = document.getElementById('plot-container');
      const tooltip = document.getElementById('tooltip');
      let scene, camera, renderer, controls, raycaster, mouse;
      let INTERSECTED;
      let focusedNodeId = null;
      let adjacencyList = new Map();
      let mouseX = 0;
      let mouseY = 0;


      // --- CYBERPUNK COLOR PALETTE ---
      const nodeColors = [
        '#00FFFF', // Electric Cyan
        '#39FF14', // Glitch Green
        '#FF00FF', // Cyber Magenta
        '#F7B500', // Data-Trace Yellow
        '#9D00FF', // Electric Purple
        '#007FFF', // Quantum Blue
      ];
      const dataCategories = [
        'General Inquiry',
        'Technical Support',
        'Sales Question',
        'Product Feedback',
        'Billing Issue',
        'Other'
      ];

      function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, plotContainer.clientWidth / plotContainer.clientHeight, 0.01, 1000);
        camera.position.set(0.2, 0.2, 0.2);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0); // Transparent background
        renderer.setSize(plotContainer.clientWidth, plotContainer.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        plotContainer.appendChild(renderer.domElement);

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        addLights();

        window.addEventListener('resize', onWindowResize, false);
        plotContainer.addEventListener('mousemove', onMouseMove, false);
        plotContainer.addEventListener('click', onClick, false);
        plotContainer.addEventListener('touchstart', onTouchStart, false);

        animate();
      }

      function onWindowResize() {
        camera.aspect = plotContainer.clientWidth / plotContainer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(plotContainer.clientWidth, plotContainer.clientHeight);
        controls.handleResize();
      }

      function onMouseMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        mouseX = event.clientX;
        mouseY = event.clientY;
      }

      function onClick(event) {
        if (INTERSECTED) {
          // If clicking the currently focused node, unfocus it. Otherwise, focus the new node.
          focusedNodeId = focusedNodeId === INTERSECTED.userData.id ? null : INTERSECTED.userData.id;
          openSidebar(INTERSECTED.userData.conversation);
        } else {
          // Clicking on the background unfocuses any node.
          focusedNodeId = null;
        }
      }
      
      function onTouchStart(event) {
          event.preventDefault();
          const rect = renderer.domElement.getBoundingClientRect();
          const touch = event.touches[0];
          mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
      
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(scene.children.filter(c => c.isMesh));
          if (intersects.length > 0) {
              const touchedNode = intersects[0].object;
              focusedNodeId = focusedNodeId === touchedNode.userData.id ? null : touchedNode.userData.id;
              openSidebar(touchedNode.userData.conversation);
          } else {
              focusedNodeId = null;
          }
      }

      function updateVisibility() {
        const activeNodeId = focusedNodeId !== null ? focusedNodeId : (INTERSECTED ? INTERSECTED.userData.id : null);

        if (activeNodeId === null) {
          // Show all if no node is active
          scene.children.forEach(child => child.visible = true);
          return;
        }

        const neighbors = new Set(adjacencyList.get(activeNodeId) || []);
        neighbors.add(activeNodeId);

        scene.children.forEach(child => {
          if (child.isMesh) { // It's a node
            child.visible = neighbors.has(child.userData.id);
          } else if (child.isLine) { // It's an edge
            const { source, target } = child.userData;
            child.visible = (source === activeNodeId && neighbors.has(target)) || (target === activeNodeId && neighbors.has(source));
          }
        });
      }


      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children.filter(c => c.isMesh));

        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) {
                    INTERSECTED.material.emissive.setHex(0x000000);
                    INTERSECTED.scale.set(1,1,1);
                }
                INTERSECTED = intersects[0].object;
                INTERSECTED.material.emissive.setHex(0x777777); // Brighter glow on hover
                INTERSECTED.scale.set(1.3, 1.3, 1.3);
                plotContainer.style.cursor = 'pointer';
            }
            const conversation = INTERSECTED.userData.conversation;
            const previewText = conversation.length > 100 ? conversation.substring(0, 100) + '...' : conversation;
            tooltip.innerHTML = previewText;
            tooltip.style.left = `${mouseX + 15}px`;
            tooltip.style.top = `${mouseY + 15}px`;
            tooltip.classList.remove('hidden');

        } else {
            if (INTERSECTED) {
                INTERSECTED.material.emissive.setHex(0x000000);
                INTERSECTED.scale.set(1,1,1);
            }
            INTERSECTED = null;
            plotContainer.style.cursor = 'grab';
            tooltip.classList.add('hidden');
        }
        
        updateVisibility();
        renderer.render(scene, camera);
      }

      initThree();

      const initialConversationData = {
        "conversations": [
          "What type of sensor is used in xiaomi phones ir blaster ...",
          "What are the benefits of using a CDN for a website? ...",
          "How to set up a basic web server with Node.js and Express?",
          "How does public-key cryptography work?",
          "What are the main differences between SQL and NoSQL databases?"
        ],
        "nodes": [
          { "id": 0, "x": 0.05, "y": -0.01, "z": 0.007, "size": 1.0 },
          { "id": 1, "x": -0.05, "y": 0.01, "z": -0.007, "size": 1.0 },
          { "id": 2, "x": 0.0, "y": 0.08, "z": 0.03, "size": 1.0 },
          { "id": 3, "x": 0.08, "y": 0.05, "z": -0.05, "size": 1.0 },
          { "id": 4, "x": -0.08, "y": -0.05, "z": 0.05, "size": 1.0 }
        ],
        "edges": [
            { "source": 0, "target": 1 },
            { "source": 1, "target": 2 },
            { "source": 1, "target": 3 },
            { "source": 3, "target": 4 }
        ]
      };

      function buildAdjacencyList(edges) {
        adjacencyList.clear();
        edges.forEach(edge => {
          if (!adjacencyList.has(edge.source)) adjacencyList.set(edge.source, []);
          if (!adjacencyList.has(edge.target)) adjacencyList.set(edge.target, []);
          adjacencyList.get(edge.source).push(edge.target);
          adjacencyList.get(edge.target).push(edge.source);
        });
      }

      function processDataForThree(graphData) {
        while(scene.children.length > 0){ 
            const object = scene.children[0];
            if(object.isMesh || object.isLine) {
                object.geometry.dispose();
                object.material.dispose();
            }
            scene.remove(object);
        }
        addLights();
        
        focusedNodeId = null; // Reset focus when new data is loaded
        buildAdjacencyList(graphData.edges || []);

        const nodeMap = new Map();

        graphData.nodes.forEach(node => {
          const geometry = new THREE.SphereGeometry((node.size || 1) * 0.008, 32, 32);
          const color = new THREE.Color(nodeColors[node.id % nodeColors.length]);
          const material = new THREE.MeshPhongMaterial({ color: color, emissive: 0x000000, shininess: 80, specular: 0x222222 });
          const sphere = new THREE.Mesh(geometry, material);
          sphere.position.set(node.x, node.y, node.z);
          sphere.userData = { id: node.id, conversation: graphData.conversations[node.id] || `Conversation for node ${node.id}` };
          scene.add(sphere);
          nodeMap.set(node.id, sphere);
        });

        if (graphData.edges) {
            graphData.edges.forEach(edge => {
                const sourceNode = nodeMap.get(edge.source);
                const targetNode = nodeMap.get(edge.target);
                if (sourceNode && targetNode) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([sourceNode.position, targetNode.position]);
                    const material = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.8 }); // Subtler lines
                    const line = new THREE.Line(geometry, material);
                    line.userData = { source: edge.source, target: edge.target };
                    scene.add(line);
                }
            });
        }
      }
      
      function addLights() {
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(1, 1, 1);
        scene.add(light);
      }

      processDataForThree(initialConversationData);

      // --- Sidebars Logic ---
      const conversationSidebar = document.getElementById('conversation-sidebar');
      const closeSidebarBtn = document.getElementById('close-sidebar-btn');
      const sidebarContent = document.getElementById('sidebar-content');
      const legendSidebar = document.getElementById('legend-sidebar');
      const legendToggleBtn = document.getElementById('legend-toggle-btn');
      const closeLegendBtn = document.getElementById('close-legend-btn');

      const openSidebar = (content) => {
          const formattedContent = content
              .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-100">$1</strong>')
              .replace(/\n/g, '<br>');
          sidebarContent.innerHTML = `<p class="leading-relaxed">${formattedContent}</p>`;
          conversationSidebar.classList.remove('translate-x-full');
      };
      const closeSidebar = () => {
          conversationSidebar.classList.add('translate-x-full');
      };

      const toggleLegend = () => {
          legendSidebar.classList.toggle('-translate-x-full');
      }

      closeSidebarBtn.addEventListener('click', closeSidebar);
      legendToggleBtn.addEventListener('click', toggleLegend);
      closeLegendBtn.addEventListener('click', toggleLegend);

      function populateLegend() {
          const legendContent = document.getElementById('legend-content');
          legendContent.innerHTML = '';
          dataCategories.forEach((category, index) => {
              const color = nodeColors[index % nodeColors.length];
              const item = document.createElement('div');
              item.classList.add('flex', 'items-center');
              item.innerHTML = `
                <div class="w-4 h-4 rounded-full mr-3 border border-white/20" style="background-color: ${color}"></div>
                <span>${category}</span>
              `;
              legendContent.appendChild(item);
          });
      }

      populateLegend();

      // --- File Upload Logic ---
      const uploadInput = document.getElementById('json-upload');
      const fileInfo = document.getElementById('file-info');
      const messageArea = document.getElementById('message-area');

      uploadInput.addEventListener('change', (event) => {
        messageArea.textContent = '';
        messageArea.classList.remove('text-green-400', 'text-red-400');
        if (event.target.files.length > 0) {
          const userFile = event.target.files[0];
          fileInfo.textContent = `Selected file: ${userFile.name}`;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const fileContent = JSON.parse(e.target.result);
              let graphDataForPlotting = null;

              const sourceData = fileContent.conversation_graph_data || fileContent;

              if (Array.isArray(sourceData.conversations) && (sourceData.nodes || sourceData.node_positions_3d)) {
                let nodes;
                if (sourceData.node_positions_3d) {
                    nodes = Object.keys(sourceData.node_positions_3d).map(nodeId => {
                        const pos = sourceData.node_positions_3d[nodeId];
                        return { id: parseInt(nodeId,10), x: pos[0], y: pos[1], z: pos[2] };
                    });
                } else {
                    nodes = sourceData.nodes;
                }
                graphDataForPlotting = { nodes: nodes, conversations: sourceData.conversations, edges: sourceData.edges };
              } else {
                throw new Error("JSON structure not recognized.");
              }

              if (graphDataForPlotting) {
                processDataForThree(graphDataForPlotting);
                messageArea.textContent = 'Visualization updated successfully.';
                messageArea.classList.add('text-green-400');
              } else {
                  throw new Error("Could not find graph data in the JSON.");
              }
            } catch (error) {
              console.error("Error processing file:", error);
              messageArea.textContent = 'Error: ' + error.message;
              messageArea.classList.add('text-red-400');
            }
          };
          reader.readAsText(userFile);
        }
      });
    });
  </script>
</body>
</html>

